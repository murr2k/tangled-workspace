<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tangled Live Stats</title>
    <style>
        :root {
            --bg-dark: #0f0f1a;
            --bg-card: rgba(255, 255, 255, 0.05);
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --accent-gray: #6b7280;
            --accent-purple: #a855f7;
            --accent-blue: #3b82f6;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #0f0f1a 100%);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 24px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            flex-wrap: wrap;
            gap: 12px;
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-red);
        }

        .status-dot.connected {
            background: var(--accent-green);
            animation: pulse 2s infinite;
        }

        #refresh-btn {
            background: transparent;
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 1rem;
            margin-left: 8px;
            transition: all 0.2s;
        }

        #refresh-btn:hover {
            background: var(--bg-card);
            color: var(--text-primary);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .card {
            background: var(--bg-card);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .card-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 12px;
            letter-spacing: 0.05em;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-bottom: 16px;
        }

        .stat-card {
            background: var(--bg-card);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .stat-value.positive { color: var(--accent-green); }
        .stat-value.negative { color: var(--accent-red); }

        .stat-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .wdl-bar {
            height: 36px;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            background: rgba(0,0,0,0.3);
        }

        .wdl-segment {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
            transition: width 0.5s ease;
            min-width: 0;
            overflow: hidden;
        }

        .wdl-segment span {
            white-space: nowrap;
        }

        .wdl-win { background: var(--accent-green); }
        .wdl-draw { background: var(--accent-gray); }
        .wdl-loss { background: var(--accent-red); }

        .wdl-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 8px;
        }

        .two-col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        @media (max-width: 700px) {
            .two-col {
                grid-template-columns: 1fr;
            }
        }

        /* Petersen Graph */
        .graph-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        .graph-container svg {
            max-width: 100%;
            height: auto;
        }

        .graph-edge {
            stroke: #6b7280;
            stroke-width: 3;
            stroke-linecap: round;
            transition: stroke 0.3s ease;
        }

        /* FM = Green, AFM = Purple (matches tangled-game.com) */
        .graph-edge.fm { stroke: var(--accent-green); stroke-width: 5; }
        .graph-edge.afm { stroke: var(--accent-purple); stroke-width: 5; }

        .graph-vertex {
            fill: var(--bg-dark);
            stroke: var(--text-secondary);
            stroke-width: 2;
        }

        /* Vertex owned by red (player 1) - matches tangled-game.com */
        .graph-vertex.red-owned { fill: #ef4444 !important; stroke: #ef4444 !important; }
        /* Vertex owned by blue (player 2) - matches tangled-game.com */
        .graph-vertex.blue-owned { fill: #3b82f6 !important; stroke: #3b82f6 !important; }

        .graph-label {
            fill: var(--text-primary);
            font-size: 10px;
            text-anchor: middle;
            dominant-baseline: central;
            font-weight: 600;
        }

        /* Recent Results */
        .recent-results {
            display: flex;
            gap: 6px;
            justify-content: center;
            margin-top: 8px;
        }

        .result-badge {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 700;
        }

        .result-badge.W { background: var(--accent-green); }
        .result-badge.D { background: var(--accent-gray); }
        .result-badge.L { background: var(--accent-red); }

        /* Score Stats */
        .score-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--glass-border);
        }

        .score-row:last-child {
            border-bottom: none;
        }

        .score-label {
            color: var(--text-secondary);
        }

        .score-value {
            font-weight: 600;
            font-family: 'SF Mono', 'Consolas', monospace;
        }

        /* Model Metrics */
        .metrics-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.25rem;
            font-weight: 700;
        }

        .metric-label {
            font-size: 0.65rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }

        /* Game Info */
        .game-info {
            text-align: center;
            margin-top: 12px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .game-score {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        /* Message */
        .message {
            text-align: center;
            padding: 48px;
            color: var(--text-secondary);
        }

        .message h2 {
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        #last-update {
            text-align: center;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 24px;
        }

        /* Trend Arrow */
        .trend-up { color: var(--accent-green); }
        .trend-down { color: var(--accent-red); }
        .trend-flat { color: var(--text-secondary); }

        /* Move Display */
        .move-display {
            font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 12px 16px;
            text-align: center;
            letter-spacing: 0.02em;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .move-display .move-num {
            color: var(--text-secondary);
            margin-right: 8px;
        }

        .move-display .move-edge {
            color: var(--text-primary);
            font-weight: 600;
        }

        .move-display .move-color-G {
            color: var(--accent-green);
            font-weight: 700;
        }

        .move-display .move-color-P {
            color: var(--accent-purple);
            font-weight: 700;
        }

        .move-display .move-score {
            margin-left: 12px;
        }

        .move-display .move-score.positive {
            color: var(--accent-green);
        }

        .move-display .move-score.negative {
            color: var(--accent-red);
        }

        .move-display .move-time {
            color: var(--text-secondary);
            margin-left: 12px;
            font-size: 0.8rem;
        }

        .move-display .move-player-opp {
            color: var(--accent-blue);
        }

        /* Game Legend */
        .game-legend {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-top: 12px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .legend-line {
            width: 20px;
            height: 3px;
            border-radius: 1px;
        }

        .legend-line.solid {
            background: var(--text-secondary);
        }

        .legend-line.dashed {
            background: repeating-linear-gradient(
                90deg,
                var(--text-secondary) 0px,
                var(--text-secondary) 6px,
                transparent 6px,
                transparent 10px
            );
        }

        /* Score Bar - center-origin like game UI */
        .score-bar-container {
            margin-top: 12px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
        }

        .score-bar-header {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }

        .score-bar-label {
            display: none;
        }

        .score-bar-value {
            font-weight: 600;
            font-family: 'SF Mono', 'Consolas', monospace;
        }

        .score-bar-value.positive { color: #ef4444; }
        .score-bar-value.negative { color: #3b82f6; }

        .score-bar {
            position: relative;
            height: 24px;
            background: #1e293b;
            border-radius: 4px;
            overflow: hidden;
        }

        .score-bar-labels {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 8px;
            font-size: 0.7rem;
            font-weight: 600;
            z-index: 2;
            pointer-events: none;
        }

        .score-bar-labels .red-label { color: #ef4444; }
        .score-bar-labels .blue-label { color: #3b82f6; }

        .score-bar-center {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--text-secondary);
            z-index: 1;
        }

        .score-bar-fill {
            position: absolute;
            top: 2px;
            bottom: 2px;
            z-index: 0;
        }

        .score-bar-fill.positive {
            background: #ef4444;
            right: 50%;
        }

        .score-bar-fill.negative {
            background: #3b82f6;
            left: 50%;
        }

        /* Strategy/Opponent display */
        .game-meta {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-top: 8px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .game-meta-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .game-meta-value {
            color: var(--text-primary);
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>TANGLED LIVE STATS</h1>
            <div class="status">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">Connecting...</span>
                <button id="refresh-btn" onclick="window.statsConn?.pollStats()" title="Force refresh">â†»</button>
            </div>
        </header>

        <div id="content">
            <!-- Initial layout shown immediately -->
        </div>

        <div id="last-update"></div>
    </div>

    <script>
        // Petersen Graph Definition
        const VERTICES = {
            0: {x: 150, y: 60},   // inner top
            1: {x: 220, y: 110},  // inner right
            2: {x: 195, y: 185},  // inner bottom-right
            3: {x: 105, y: 185},  // inner bottom-left
            4: {x: 80,  y: 110},  // inner left
            5: {x: 25,  y: 90},   // outer left (US)
            6: {x: 150, y: 10},   // outer top (HUB)
            7: {x: 275, y: 90},   // outer right (OPP)
            8: {x: 235, y: 230},  // outer bottom-right
            9: {x: 65,  y: 230},  // outer bottom-left
        };

        const EDGES = [
            [0, 2], [0, 3], [0, 6], [1, 3], [1, 4],
            [1, 7], [2, 4], [2, 8], [3, 9], [4, 5],
            [5, 6], [5, 9], [6, 7], [7, 8], [8, 9]
        ];

        // Map each vertex to its connected edges
        const VERTEX_EDGES = {};
        EDGES.forEach((edge, i) => {
            const [v1, v2] = edge;
            if (!VERTEX_EDGES[v1]) VERTEX_EDGES[v1] = [];
            if (!VERTEX_EDGES[v2]) VERTEX_EDGES[v2] = [];
            VERTEX_EDGES[v1].push(i);
            VERTEX_EDGES[v2].push(i);
        });

        function getVertexOwner(vertexId, edgeStates) {
            // Count G (green/FM) and P (purple/AFM) edges connected to this vertex
            const connectedEdges = VERTEX_EDGES[vertexId] || [];
            let greenCount = 0;
            let purpleCount = 0;

            connectedEdges.forEach(edgeIdx => {
                const state = edgeStates[edgeIdx];
                if (state === 'G') greenCount++;
                else if (state === 'P') purpleCount++;
            });

            // Vertex is owned by player with majority (2+ of 3 edges)
            if (greenCount >= 2) return 'green';
            if (purpleCount >= 2) return 'purple';
            return null; // No owner yet
        }

        function createPetersenSVG(edgeStates = '', vertexStates = '') {
            const padding = 5;
            const width = 300;
            const height = 250;

            let svg = `<svg viewBox="${-padding} ${-padding} ${width + padding*2} ${height + padding*2}" width="${width}" height="${height}">`;

            // Draw edges - Green for FM, Purple for AFM (matches tangled-game.com)
            EDGES.forEach((edge, i) => {
                const [v1, v2] = edge;
                const p1 = VERTICES[v1];
                const p2 = VERTICES[v2];
                const state = edgeStates[i] || '-';

                let edgeClass = 'graph-edge';
                if (state === 'G') edgeClass += ' fm';
                else if (state === 'P') edgeClass += ' afm';

                svg += `<line class="${edgeClass}" x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}"/>`;
            });

            // Draw vertices - use vertex_state if provided (R=red player 1, B=blue player 2)
            console.log('Drawing vertices with states:', vertexStates);
            Object.entries(VERTICES).forEach(([id, pos]) => {
                const idx = parseInt(id);
                let vertexClass = 'graph-vertex';

                // Use vertex_state data if available (read from game page)
                if (vertexStates && vertexStates.length > idx) {
                    const vState = vertexStates[idx];
                    console.log(`V${idx}: state='${vState}'`);
                    if (vState === 'R') vertexClass += ' red-owned';
                    else if (vState === 'B') vertexClass += ' blue-owned';
                }
                // No fallback calculation - vertices only colored when game data provides it

                svg += `<circle class="${vertexClass}" cx="${pos.x}" cy="${pos.y}" r="12"/>`;
                svg += `<text class="graph-label" x="${pos.x}" y="${pos.y}">${id}</text>`;
            });

            svg += '</svg>';
            return svg;
        }

        function formatTrend(value) {
            if (value === null || value === undefined) return '-';
            const sign = value >= 0 ? '+' : '';
            const cls = value > 0 ? 'trend-up' : (value < 0 ? 'trend-down' : 'trend-flat');
            const arrow = value > 0 ? '&#9650;' : (value < 0 ? '&#9660;' : '&#9644;');
            return `<span class="${cls}">${arrow} ${sign}${value.toFixed(3)}</span>`;
        }

        function formatScore(value) {
            if (value === null || value === undefined) return '-';
            const sign = value >= 0 ? '+' : '';
            return sign + value.toFixed(3);
        }

        function formatETA(eta) {
            if (!eta || !eta.estimated_end) return '--';
            try {
                const end = new Date(eta.estimated_end);
                const now = new Date();
                const diffMs = end - now;

                if (diffMs < 0) return 'Complete';

                // Show clock time (e.g., "3:45 PM") with remaining duration
                const timeStr = end.toLocaleTimeString([], {hour: 'numeric', minute: '2-digit'});
                const hours = Math.floor(diffMs / (1000 * 60 * 60));
                const mins = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));

                let remaining;
                if (hours > 24) {
                    const days = Math.floor(hours / 24);
                    remaining = `${days}d ${hours % 24}h`;
                } else if (hours > 0) {
                    remaining = `${hours}h ${mins}m`;
                } else {
                    remaining = `${mins}m`;
                }

                return `${timeStr} (${remaining})`;
            } catch (e) {
                return '--';
            }
        }

        function renderRecentResults(recent5) {
            if (!recent5) return '';
            return recent5.split('').map(r =>
                `<div class="result-badge ${r}">${r}</div>`
            ).join('');
        }

        function formatMoveDisplay(move) {
            if (!move) return '<span style="color: var(--text-secondary);">Waiting for move...</span>';

            const num = String(move.number || 0).padStart(2, ' ');
            const edge = move.edge;
            const color = move.color || '?';
            const colorName = color === 'G' ? 'Green ' : 'Purple';
            const timeStr = move.thinking_time != null ? `${move.thinking_time.toFixed(1)}s` : '    ';
            const playerClass = move.player === 'opponent' ? 'move-player-opp' : '';

            return `<span class="move-num ${playerClass}">Edge ${num}/15</span>` +
                   `<span class="move-edge">E${edge}</span> ` +
                   `<span class="move-color-${color}">${colorName}</span>` +
                   `<span class="move-time">${timeStr}</span>`;
        }

        function formatScoreBar(score) {
            // Score bar: 0 is center, +1 full left (red), -1 full right (blue)
            // Positive = our favor (red), Negative = opponent favor (blue)
            if (score == null) return '';

            const scoreStr = (score >= 0 ? '+' : '') + score.toFixed(3);
            const scoreClass = score > 0 ? 'positive' : (score < 0 ? 'negative' : '');

            // Calculate bar width (0-50% of half the bar)
            const pct = Math.min(Math.abs(score), 1) * 50;
            const fillStyle = score >= 0
                ? `width: ${pct}%`  // positive: red bar extends left from center
                : `width: ${pct}%`; // negative: blue bar extends right from center

            return `
                <div class="score-bar-container">
                    <div class="score-bar-header">
                        <span class="score-bar-label">Current Score:</span>
                        <span class="score-bar-value ${scoreClass}">${scoreStr}</span>
                    </div>
                    <div class="score-bar">
                        <div class="score-bar-labels">
                            <span class="red-label">Red</span>
                            <span class="blue-label">Blue</span>
                        </div>
                        <div class="score-bar-center"></div>
                        <div class="score-bar-fill ${scoreClass}" style="${fillStyle}"></div>
                    </div>
                </div>
            `;
        }

        function formatGameMeta(session) {
            if (!session) return '';
            const strategy = session.strategy || '-';
            const opponent = session.opponent || '-';
            // Capitalize first letter of opponent name
            const oppDisplay = opponent.charAt(0).toUpperCase() + opponent.slice(1);

            return `
                <div class="game-meta">
                    <div class="game-meta-item">
                        <span class="game-meta-label">Strategy:</span>
                        <span class="game-meta-value">${strategy}</span>
                    </div>
                    <div class="game-meta-item">
                        <span class="game-meta-label">vs</span>
                        <span class="game-meta-value">${oppDisplay}</span>
                    </div>
                </div>
            `;
        }

        class StatsConnection {
            constructor() {
                this.ws = null;
                this.reconnectDelay = 1000;
                this.maxReconnectDelay = 30000;
                this.lastUpdate = null;
                this.lastMove = null;
                this.lastBoardState = '---------------';  // 15 unplayed edges
                this.lastVertexState = '-----R-B--';      // V5=red (player 1), V7=blue (player 2)
                this.hasReceivedData = false;
                this.lastStats = null;
                this.connect();
                this.startUpdateTimer();
            }

            connect() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const url = `${protocol}//${window.location.host}/ws/subscribe`;

                this.ws = new WebSocket(url);

                this.ws.onopen = () => {
                    this.reconnectDelay = 1000;
                    this.updateStatus(true);
                };

                this.ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    console.log('WS received:', data.type);

                    if (data.type === 'full_state') {
                        // Full state message - the ONLY message type we handle
                        this.lastUpdate = new Date();
                        this.hasReceivedData = true;

                        // Update move/board state if present
                        if (data.move) this.lastMove = data.move;
                        if (data.board_state) this.lastBoardState = data.board_state;
                        if (data.vertex_state) this.lastVertexState = data.vertex_state;

                        // Merge any stats data into lastStats
                        if (data.results || data.scores || data.session) {
                            this.lastStats = {...this.lastStats, ...data};
                        }

                        console.log('full_state: board=' + this.lastBoardState + ' vertices=' + this.lastVertexState);

                        // Always render full dashboard - use lastStats for any missing data
                        this.updateDashboard(this.lastStats || {});
                    }
                    // Ignore any other message types (connected, pong, etc.)
                };

                this.ws.onclose = () => {
                    this.updateStatus(false);
                    this.scheduleReconnect();
                };

                this.ws.onerror = () => {
                    this.ws.close();
                };
            }

            scheduleReconnect() {
                setTimeout(() => {
                    this.reconnectDelay = Math.min(
                        this.reconnectDelay * 2,
                        this.maxReconnectDelay
                    );
                    this.connect();
                }, this.reconnectDelay);
            }

            updateStatus(connected) {
                const dot = document.getElementById('status-dot');
                const text = document.getElementById('status-text');

                if (connected) {
                    dot.classList.add('connected');
                    text.textContent = 'Connected';
                } else {
                    dot.classList.remove('connected');
                    text.textContent = 'Reconnecting...';
                }
            }

            startUpdateTimer() {
                // Update "last update" display every second
                setInterval(() => {
                    const el = document.getElementById('last-update');
                    if (this.lastUpdate) {
                        const seconds = Math.floor((new Date() - this.lastUpdate) / 1000);
                        if (seconds < 60) {
                            el.textContent = `Last update: ${seconds}s ago`;
                        } else {
                            const mins = Math.floor(seconds / 60);
                            el.textContent = `Last update: ${mins}m ${seconds % 60}s ago`;
                        }
                    }
                }, 1000);

                // Fallback: poll REST endpoint every 5 seconds if no recent WebSocket data
                setInterval(() => {
                    const secondsSinceUpdate = this.lastUpdate
                        ? Math.floor((new Date() - this.lastUpdate) / 1000)
                        : 999;

                    // Poll if no update in last 8 seconds (more aggressive fallback)
                    if (secondsSinceUpdate > 8) {
                        this.pollStats();
                    }
                }, 5000);
            }

            async pollStats() {
                try {
                    const response = await fetch('/api/stats');
                    const data = await response.json();
                    if (data.type === 'stats_update') {
                        console.log('Fallback poll: got stats');
                        this.lastUpdate = new Date();
                        this.lastStats = data;
                        this.hasReceivedData = true;
                        // Check for embedded move data
                        if (data.last_move) {
                            this.lastMove = data.last_move.move;
                            if (data.last_move.board_state) {
                                this.lastBoardState = data.last_move.board_state;
                            }
                            if (data.last_move.vertex_state) {
                                this.lastVertexState = data.last_move.vertex_state;
                            }
                        }
                        this.updateDashboard(data);
                    } else if (data.type === 'move_only' && data.last_move) {
                        console.log('Fallback poll: got move only');
                        this.lastUpdate = new Date();
                        this.lastMove = data.last_move.move;
                        if (data.last_move.board_state) {
                            this.lastBoardState = data.last_move.board_state;
                        }
                        if (data.last_move.vertex_state) {
                            this.lastVertexState = data.last_move.vertex_state;
                        }
                        this.hasReceivedData = true;
                        this.showGameOnlyUI();
                    }
                } catch (e) {
                    console.log('Fallback poll failed:', e);
                }
            }

            countColoredEdges() {
                // Count non-'-' characters in board state (G or P = colored edge)
                if (!this.lastBoardState) return 0;
                return (this.lastBoardState.match(/[GP]/g) || []).length;
            }

            updateMoveDisplay() {
                const el = document.getElementById('move-display');
                if (el && this.lastMove) {
                    el.innerHTML = formatMoveDisplay(this.lastMove);
                }
                // Also update the graph if we have board state
                const graphEl = document.getElementById('current-graph');
                if (graphEl && this.lastBoardState) {
                    graphEl.innerHTML = createPetersenSVG(this.lastBoardState, this.lastVertexState);
                }
                // Update score display
                const scoreEl = document.getElementById('current-score');
                if (scoreEl && this.lastMove && this.lastMove.score != null) {
                    const score = this.lastMove.score;
                    const scoreStr = (score >= 0 ? '+' : '') + score.toFixed(3);
                    const scoreClass = score > 0 ? 'positive' : (score < 0 ? 'negative' : '');
                    scoreEl.innerHTML = `<span class="stat-value ${scoreClass}">${scoreStr}</span>`;
                }
            }

            updateDashboard(stats) {
                const content = document.getElementById('content');
                // Note: Don't clear move data on stats update - only clear when run completes
                // The move data from move_update is more current than stats.current_game

                const session = stats.session || {};
                const results = stats.results || {};
                const scores = stats.scores || {};
                const trends = stats.trends || {};
                const model = stats.model || {};
                const currentGame = stats.current_game;
                const eta = stats.eta || {};

                const total = (results.wins || 0) + (results.draws || 0) + (results.losses || 0);
                const winPct = total > 0 ? (results.wins / total) * 100 : 0;
                const drawPct = total > 0 ? (results.draws / total) * 100 : 0;
                const lossPct = total > 0 ? (results.losses / total) * 100 : 0;

                const avgClass = scores.avg > 0 ? 'positive' : (scores.avg < 0 ? 'negative' : '');

                content.innerHTML = `
                    <!-- Top Stats Row -->
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value">${session.run_id != null ? session.run_id : '-'}</div>
                            <div class="stat-label">Run</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${session.current_game || 0}/${session.planned_games || '?'}</div>
                            <div class="stat-label">Game</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${formatETA(eta)}</div>
                            <div class="stat-label">ETA</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value ${avgClass}">${scores.avg !== undefined ? formatScore(scores.avg) : '-'}</div>
                            <div class="stat-label">Avg Score</div>
                        </div>
                    </div>

                    <!-- W/D/L Bar -->
                    <div class="card">
                        <div class="card-title">Results</div>
                        <div class="wdl-bar">
                            <div class="wdl-segment wdl-win" style="width: ${winPct}%">
                                ${winPct >= 10 ? `<span>${results.wins || 0}W</span>` : ''}
                            </div>
                            <div class="wdl-segment wdl-draw" style="width: ${drawPct}%">
                                ${drawPct >= 10 ? `<span>${results.draws || 0}D</span>` : ''}
                            </div>
                            <div class="wdl-segment wdl-loss" style="width: ${lossPct}%">
                                ${lossPct >= 10 ? `<span>${results.losses || 0}L</span>` : ''}
                            </div>
                        </div>
                        <div class="wdl-labels">
                            <span>${results.wins || 0} wins (${winPct.toFixed(0)}%)</span>
                            <span>${results.draws || 0} draws (${drawPct.toFixed(0)}%)</span>
                            <span>${results.losses || 0} losses (${lossPct.toFixed(0)}%)</span>
                        </div>
                    </div>

                    <!-- Latest Move Display -->
                    <div class="card">
                        <div class="card-title">Latest Move</div>
                        <div class="move-display" id="move-display">
                            ${this.lastMove ? formatMoveDisplay(this.lastMove) : '<span style="color: var(--text-secondary);">Waiting for move...</span>'}
                        </div>
                        ${formatScoreBar(this.lastMove?.score)}
                        ${formatGameMeta(session)}
                    </div>

                    <!-- Two Column Layout -->
                    <div class="two-col">
                        <!-- Current Game -->
                        <div class="card">
                            <div class="card-title">Current Game</div>
                            <div class="graph-container" id="current-graph">
                                ${createPetersenSVG(this.lastBoardState || currentGame?.state || '', this.lastVertexState || '')}
                            </div>
                            <div class="game-info">
                                ${currentGame || this.lastMove ? `
                                    <div id="current-score" class="game-score">${formatScore(this.lastMove?.score ?? currentGame?.score)}</div>
                                    <div>Edges colored: ${this.countColoredEdges()}/15</div>
                                ` : '<div>No active game</div>'}
                            </div>
                            <div class="game-legend">
                                <span class="legend-item"><span class="legend-color" style="background: var(--accent-green);"></span> FM</span>
                                <span class="legend-item"><span class="legend-color" style="background: var(--accent-purple);"></span> AFM</span>
                                <span class="legend-item"><span class="legend-color" style="background: #6b7280;"></span> Unplayed</span>
                            </div>
                        </div>

                        <!-- Score Stats -->
                        <div class="card">
                            <div class="card-title">Score Statistics</div>
                            <div class="score-row">
                                <span class="score-label">Average</span>
                                <span class="score-value">${formatScore(scores.avg)}</span>
                            </div>
                            <div class="score-row">
                                <span class="score-label">Median</span>
                                <span class="score-value">${formatScore(scores.median)}</span>
                            </div>
                            <div class="score-row">
                                <span class="score-label">Min / Max</span>
                                <span class="score-value">${formatScore(scores.min)} / ${formatScore(scores.max)}</span>
                            </div>
                            <div class="score-row">
                                <span class="score-label">Std Dev</span>
                                <span class="score-value">${scores.std != null ? scores.std.toFixed(3) : '-'}</span>
                            </div>
                            <div class="score-row">
                                <span class="score-label">Trend</span>
                                <span class="score-value">${formatTrend(trends.score_trend)}</span>
                            </div>
                            <div class="card-title" style="margin-top: 16px;">Recent</div>
                            <div class="recent-results">
                                ${renderRecentResults(trends.recent_5)}
                            </div>
                        </div>
                    </div>

                    <!-- Opponent Model Metrics -->
                    <div class="card">
                        <div class="card-title">Opponent Model</div>
                        <div class="metrics-row">
                            <div>
                                <div class="metric-value">${model.avg_entropy != null ? model.avg_entropy.toFixed(2) : '-'}</div>
                                <div class="metric-label">Entropy</div>
                            </div>
                            <div>
                                <div class="metric-value">${model.avg_top3_hit != null ? (model.avg_top3_hit * 100).toFixed(1) + '%' : '-'}</div>
                                <div class="metric-label">Top-3 Hit</div>
                            </div>
                            <div>
                                <div class="metric-value">${model.avg_pred_accuracy != null ? (model.avg_pred_accuracy * 100).toFixed(1) + '%' : '-'}</div>
                                <div class="metric-label">Accuracy</div>
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            window.statsConn = new StatsConnection();
            // Show empty dashboard immediately
            window.statsConn.updateDashboard({
                session: {},
                results: {},
                scores: {},
                trends: {},
                model: {},
                eta: {}
            });
            // Also try to fetch stats immediately
            window.statsConn.pollStats();
        });
    </script>
</body>
</html>
